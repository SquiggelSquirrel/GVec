@tool
class_name SkeletonPathShape2D
extends Node

## Apply the pose of a [Skeleton2D] to the points output by a [PathShape2D].
##
## This node should only be the immediate child of a [Skeleton2D]. It takes
## the points generated by a [PathShape2D] and writes them to a
## [PathShape2DWritable], which can then be referenced elsewhere, such as by
## a [PathToPoints] node.


## Options for when to update the output path points.
enum UpdateMode {
	PROCESS_FRAME, ## Every _process frame
	MANUAL, ## Only when [method update] is called
	MANUAL_DEFERRED, ## On _process frame after [method update] has been called
}
## When to update the output path points - see [enum UpdateMode]
@export var update_mode: UpdateMode = UpdateMode.PROCESS_FRAME

## The [PathShape2D] to get points from
@export var path_in :PathShape2D

## The [PathShape2DWritable] to write points to
@export var path_out :PathShape2DWritable

## An [Array] of [Curve] resources. There should be one for each [Bone2D], of
## the parent [Skeleton2D], in the same order that bones are exposed. Excess
## curvs are ignored. [Bone2D] nodes without a corresponding [Curve] resource
## will not affect the output points. Each [Curve] will be sampled at intervals
## corresponding to each point from the input path, and each point will be
## affected by the pose of each bone in proportion to the weight returned.
## (Points for which no weight is returned will not be modified).
@export var weight_curves :Array[Curve] = []

var _awaiting_deferred_update := false


func _process(_delta):
	if ! path_in is PathShape2D:
		return
	if ! path_out is PathShape2DWritable:
		return
	match update_mode:
		UpdateMode.PROCESS_FRAME:
			_update()
		UpdateMode.MANUAL_DEFERRED:
			if _awaiting_deferred_update:
				_update()
				_awaiting_deferred_update = false


## Call to manually update the output points. Will be immediate unless
## [member update_mode] is in mode [constant UpdateMode.MANUAL_DEFERRED], in
## which case will only be immediate if force is set to true.
func update(force := false):
	if update_mode == UpdateMode.MANUAL_DEFERRED and ! force:
		_awaiting_deferred_update = true
	else:
		_update()


func _update():
	var skeleton = get_parent() as Skeleton2D
	if skeleton == null:
		return
	var baked_point_count: int = path_in.get_baked_points().size()
	var points_offset: int = 0
	var segments: Array[PackedVector2Array] = []
	for segment_index in path_in.get_segment_count():
		var segment_points := PackedVector2Array()
		for point in path_in.get_segment_baked_points(segment_index):
			var weight_offset := float(points_offset) / baked_point_count
			var weighted_points := PackedVector2Array()
			var total_weight: float = 0
			for bone_index in skeleton.get_bone_count():
				var weight: float = 0.0
				if bone_index < weight_curves.size():
					if weight_curves[bone_index] == null:
						continue
					weight = weight_curves[bone_index].sample(weight_offset)
				if weight == 0.0:
					continue
				var bone := skeleton.get_bone(bone_index)
				var rest_transform := bone.get_skeleton_rest()
				var pose_transform := bone.get_relative_transform_to_parent(
						skeleton)
				var resting_point := point * rest_transform
				var posed_point := pose_transform * resting_point
				weighted_points.append(posed_point * weight)
				total_weight += weight
			
			if weighted_points.size() == 0:
				segment_points.append(point)
			else:
				var sum_point := Vector2.ZERO
				for p in weighted_points:
					sum_point += p
				segment_points.append(sum_point / total_weight)
		
			points_offset += 1
		points_offset -= 1
		segments.append(segment_points)
	path_out.segments = segments
