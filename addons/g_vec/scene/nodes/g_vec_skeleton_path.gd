@tool
class_name GVecSkeletonWeights
extends Node2D

## Apply the pose of a [Skeleton2D] to the points output by a [GVecPath].
##
## This node should only be the immediate child of a [Skeleton2D]. It takes
## the points generated by a [GVecPath] and writes them to a
## [GVecPathWritable], which can then be referenced elsewhere, such as by
## a [PathToPoints] node.

## Options for when to update the output path points.
enum UpdateMode {
	PROCESS_FRAME, ## Every _process frame
	MANUAL, ## Only when [method update] is called
	MANUAL_DEFERRED, ## On _process frame after [method update] has been called
}
## When to update the output path points - see [enum UpdateMode]
@export var update_mode: UpdateMode = UpdateMode.PROCESS_FRAME

## The [Skeleton2D] to use
@export var skeleton: Skeleton2D

## The [GVecPath] to get points from
@export var path_in :GVecPath

## The [GVecPathWritable] to write points to
@export var path_out :GVecPathWritable

@export var recalculate_weights := false:
	set(value):
		if value:
			update_weights()
@export var force_update := false:
	set(value):
		if value:
			_update()
@export var weight_bone_indices: PackedInt32Array = []
@export var weights: Array[Array] = []
var _awaiting_deferred_update := false


func _process(_delta):
	if ! path_in is GVecPath:
		return
	if ! path_out is GVecPathWritable:
		return
	match update_mode:
		UpdateMode.PROCESS_FRAME:
			_update()
		UpdateMode.MANUAL_DEFERRED:
			if _awaiting_deferred_update:
				_update()
				_awaiting_deferred_update = false


## Call to manually update the output points. Will be immediate unless
## [member update_mode] is in mode [constant UpdateMode.MANUAL_DEFERRED], in
## which case will only be immediate if force is set to true.
func update(force := false):
	if update_mode == UpdateMode.MANUAL_DEFERRED and ! force:
		_awaiting_deferred_update = true
	else:
		_update()


func update_weights() -> void:
	weight_bone_indices.clear()
	weights.clear()
	
	if skeleton == null:
		return
	
	for weight_node in get_children():
		if weight_node.bone_index > -1:
			weight_bone_indices.append(weight_node.bone_index)
	
	var weights_count := weight_bone_indices.size()
	for segment_index in path_in.get_segment_count():
		var segment := path_in.get_segment_baked_points(segment_index)
		var segment_weights := []
		for i in weights_count:
			segment_weights.append([] as PackedFloat32Array)
		
		for point_index in segment.size():
			var point := segment[point_index]
			
			var raw_weights: PackedFloat32Array = []
			for weight_node in get_children():
				if ! bool(weight_node.bone_index > -1):
					continue
				raw_weights.append(weight_node.get_distance_at_global_point(to_global(point)))
			
			var total_weight := 0.0
			for weight in raw_weights:
				total_weight += weight
			
			for weight_index in weights_count:
				segment_weights[weight_index].append(raw_weights[weight_index] / total_weight)
		
		weights.append(segment_weights)


func _get_bone_pose_transform(bone: Bone2D) -> Transform2D:
	var rest := bone.rest
	var p := bone.get_parent()
	while p is Bone2D:
		rest = p.rest * rest
		p = p.get_parent()
	return rest * bone.get_relative_transform_to_parent(p).affine_inverse()


func _update():
	if skeleton == null:
		return
	
	if weights.size() != path_in.get_segment_count():
		return
	
	var transforms: Array[Transform2D] = []
	for bone_index in weight_bone_indices:
		var bone := skeleton.get_bone(bone_index)
		transforms.append(_get_bone_pose_transform(bone))
	
	var segments_out: Array[PackedVector2Array] = []
	for segment_index in path_in.get_segment_count():
		var segment_out: PackedVector2Array = []
		var segment := path_in.get_segment_baked_points(segment_index)
		
		if weights[segment_index][0].size() != segment.size():
			return
			
		for point_index in segment.size():
			var point := segment[point_index]
			var transformed_point := Vector2.ZERO
			var unmodified := true
			for weight_index in weight_bone_indices.size():
				var weight: float = weights[segment_index][weight_index][point_index]
				if weight > 0.0:
					unmodified = false
					transformed_point += point * transforms[weight_index] * weight
			if unmodified:
				segment_out.append(point)
			else:
				segment_out.append(transformed_point)
		segments_out.append(segment_out)
	
	path_out.segments = segments_out
